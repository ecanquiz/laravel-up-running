import{_ as e,c as a,o,V as r}from"./chunks/framework.D9sOcAzr.js";const _=JSON.parse('{"title":"Caché de Rutas","description":"","frontmatter":{},"headers":[],"relativePath":"routing-and-controllers/route-caching.md","filePath":"routing-and-controllers/route-caching.md"}'),c={name:"routing-and-controllers/route-caching.md"},s=r('<h1 id="cache-de-rutas" tabindex="-1">Caché de Rutas <a class="header-anchor" href="#cache-de-rutas" aria-label="Permalink to &quot;Caché de Rutas&quot;">​</a></h1><p>Si buscas exprimir cada milisegundo de tu tiempo de carga, es posible que quieras echar un vistazo al <em>almacenamiento en caché de rutas</em>. Una de las partes del arranque de Laravel que puede tardar entre unas pocas docenas y unos pocos cientos de milisegundos es el análisis de los archivos <em>routes/*</em>, y el almacenamiento en caché de rutas acelera este proceso drásticamente.</p><p>Para almacenar en caché el archivo de rutas, debe utilizar todas las rutas de controlador, redireccionamiento, vista y recurso (sin clausuras de ruta). Si su aplicación no utiliza ninguna clausura de ruta, puede ejecutar <code>php artisan route:cache</code> y Laravel serializará los resultados de sus archivos <em>routes/*</em>. Si desea eliminar el caché, ejecute <code>php artisan route:clear</code>.</p><p>Aquí está el inconveniente: Laravel ahora comparará las rutas con ese archivo almacenado en caché en lugar de con los archivos de <em>rutas/*</em> reales. Puedes realizar cambios ilimitados en tus archivos de rutas y no tendrán efecto hasta que ejecutes <code>route:cache</code> nuevamente. Esto significa que tendrás que volver a almacenar en caché cada vez que realices un cambio, lo que genera muchas posibilidades de confusión.</p><p>Esto es lo que recomendaría en su lugar: dado que Git ignora el archivo de caché de ruta de todos modos de forma predeterminada, considere usar solo el almacenamiento en caché de ruta en su servidor de producción y ejecute el comando <code>php artisan route:cache</code> cada vez que implemente un código nuevo (ya sea a través de un gancho posterior a la implementación de Git, un comando de implementación de Forge o como parte de cualquier otro sistema de implementación que use). De esta manera, no tendrá problemas de desarrollo local confusos, pero su entorno remoto aún se beneficiará del almacenamiento en caché de ruta.</p>',5),n=[s];function t(i,d,u,l,m,h){return o(),a("div",null,n)}const v=e(c,[["render",t]]);export{_ as __pageData,v as default};
